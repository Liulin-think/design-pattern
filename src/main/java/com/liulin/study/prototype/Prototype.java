package com.liulin.study.prototype;

import java.util.ArrayList;

/**
 * 【原型模式】 
 * 【原型模式】（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
 * 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。
 * 我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
 * 
 * 【介绍】 【意图】：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 
 * 【主要解决】：在运行期建立和删除原型。 
 * 【何时使用】：
 * 1、当一个系统应该独立于它的产品创建，构成和表示时。
 * 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。
 * 3、为了避免创建一个与产品类层次平行的工厂类层次时。
 * 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
 * 【如何解决】：利用已有的一个原型对象，快速地生成和原型对象一样的实例。 
 * 【关键代码】： 
 * 1、实现克隆操作，在 JAVA 继承 Cloneable，重写clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。
 * 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。 
 * 【应用实例】： 
 * 1、细胞分裂。
 * 2、JAVA 中的 Object clone() 方法。 
 * 【优点】： 
 * 1、性能提高。 
 * 2、逃避构造函数的约束。 
 * 【缺点】：
 * 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。
 * 2、必须实现 Cloneable 接口。 
 * 【使用场景】：
 * 1、资源优化场景。
 * 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
 * 3、性能和安全要求的场景。 
 * 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
 * 5、一个对象多个修改者的场景。
 * 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。
 * 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。
 * 原型模式已经与Java 融为浑然一体，大家可以随手拿来使用。 
 * 【注意事项】： 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。
 * 浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。
 * 
 * 1.使用原型模式复制对象不会调用类的构造方法。
 * 因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。
 * 不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？
 * 单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。
 * 但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。
 * 
 * 2.深拷贝与浅拷贝。 Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。
 * 如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。 浅拷贝:引用对象拷贝引用地址,拷贝内容引用对象值发生改变时,原型内容也会发生改变
 * 深拷贝:引用对象拷贝对象内容,拷贝内容引用对象值发生改变时,原型内容不会发生改变
 * 
 * @author liulin_think
 *
 */
public class Prototype implements Cloneable {

	private static Book book = new Book();
	static {
		ArrayList<String> list = new ArrayList<>();
		list.add("数学书");
		list.add("语文书");
		list.add("英语书");
		book.setList(list);
	}
	
	public static void main(String[] args) throws CloneNotSupportedException {
		Book cloneBook = book.clone();
		ArrayList<String> list = cloneBook.getList();
		list.remove(0);
		System.out.println(list.size());
		
		System.out.println(book.getList().size());
	}
}
